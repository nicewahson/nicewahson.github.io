---
title: 读写文件续
date: 2016-12-06 11:20:45
tags: 文件操作
categories: nodejs笔记
---
var fs=require('fs'); //同步读取，读取配置文件时可以使用
fs.readFileSync('./index.html','utf-8');
fs.readFile('./index.html','utf-8',function(err,data){
					console.log(data);//操作完毕后打印结果
					}) //异步读取
fs.readFile(filename,[options],callback);如果不在options参数中指定encoding参数，那么读取的结果得到的是一个二进制buffer对象。options中可以用的属性,flag(以何种方式读或是写),encoding
fs.writeFile(filename,data,[options],callback);options中可以用的属性，flag,mode(读写权限),encoding(可指定属性值为'utf-8','ascii','base64',当data为buffer对象时该属性自动忽略)
fs.appendFile(...),参数同上，在文件底部追加数据，和上面不同的是，options中的flag属性默认值为'a',表示向文件底部追加，如果文件不存在，创建文件

从指定位置读写文件
开始读写之前,先fs.open(filename,flags,[mode],function(err,fd){...}),fd是文件描述符
然后
fs.read(fd,buffer,offset,length,position,callback),
参数： fd:open方法返回的文件描述符，buffer是一个Buffer对象，表示将文件数据读取到哪个缓冲区，offset指定向缓冲区写入数据时的开始写入位置，length参数用于指定从文件中读取的字节数，
position用于指定读取文件时的开始位置(以字节为单位),callback指定,function(err,bytesRead,buffer){//bytesRead参数值代表实际读取的字节数，buffer为被读取的缓存区对象}

如果position为null,表示从当前位置开始继续读取(前一次读取的开始位置+字节数)，应该写在上一次read方法的回调里

write方法：fs.write(fd,buffer,offset,length,position,callback)
buffer为被写入的缓冲区，offset为指定从缓冲区中读取数据时的开始位置，length为写入的字节数，position为写入文件时的开始位置，callback:function(err,written,buffer),written代表实际写入字节数
position为null时，表示从当前位置开始继续写入。当想要向文件中追加数据时，需要在open方法中设置flag为'a',只是一次的写入可以是'w'

在写完之后，可以调用close方法，fs.close(fd,[callback]),callback中参数为err

write方法是将数据写入到内存，再将内存中数据写入到文件，因此当写了一些数据，并不代表内存缓冲区中已经空了，可能还有数据，这时候调用close方法会有数据丢失的问题，这时候需要一个方法
fs.fsync(fd,[callback])，文件同步操作,调用close方法后再进行调用将内存缓冲区的数据全部写到文件中

fs.mkdir(path,[mode],callback),path是被创建的目录的完整路径及目录名,callback是创建完成时的回调
fs.readdir(path,callback),callback格式function(err,files){}
fs.stat(path,callback),fs.lstat(path,callback),查看文件或目录信息,callback为function(err,stats),stats是一个fs.Stats对象
检查文件或目录是否存在，fs.exists(path,callback),path是全路径,callback为function(exists){},exists是true或false
获取文件或目录绝对路径，fs.realpath(path,[cache],callback),cache是一个对象，存放一些预先指定的路径,function(err,resolvedPath){},后一个参数是全路径
var cache = {'/etc':'/private/etc'};fs.realpath('/etc/passwd',cache,function(err,resolvedPath){})

修改文件访问时间和修改时间
fs.utimes(path,atime,mtime,callback),atime是指定修改后的访问时间,mtime是修改后的修改时间
修改文件或目录的读写权限
fs.chmod(path,mode,callback),chmod: user group other,read-write-excute
移动文件或目录
fs.rename(oldpath,newpath,callback),oldpath是被移动文件或目录的完整路径及文件或目录名，newpath是移动后的完整路径及文件或目录名
截断文件
fs.truncate(path,len,callback),len是截断后的文件大小(单位是字节数)
删除空目录
fs.rmdir(path,callback)
监视文件或目录
fs.watchFile(filename,[options],listener),文件名filename，options是一个对象，可以用一个persistent:true(false)表示指定当指定了被监视的文件后是否停止当前正在运行的程序，也可以是interval:xxx，整数，
表示多少时间监视一次,callback为function(curr,prev){}
fs.unwatch(filename,[listener]),取消监视
ReadStream读取文件
fs.createReadStream(path,[options]),返回一个file文件输入流,在这里对其添加事件回调
var file = fs.createReadStream('./a.txt',{start:3,end:12});
file.on('open',function(fd){console.log('文件打开')});
file.on('data',function(data){console.log('文件读到数据')});
WriteStream写入文件
var out = fs.createWriteStream(path,[options])，返回一个输出流，out.write(data,[encoding],[callback]),该方法返回一个bool值，表示缓存区中是否已经满，满了为false
复制文件方法
pipe(destination,[options]),destination是写入流数据的对象，options对象中可以使用一个end属性，为true的话表示读完数据后关闭文件，false的话则不关闭，还可以继续写入，默认为true

path模块
normalize(path)将非标准路径字符串转换为标准字符串
join([path1],[path2]...),将多个参数值字符串结合为一个路径字符串
resolve解析路径
relative(from,to)获取两个相对路径之间的关系
dirname(path),获取路径中的目录名
basename(path,[ext]),获取路径中的文件名，path为完整路径，ext为可选参数，用于在方法返回的文件名中去除该文件的扩展名
extname(path),获取文件扩展名



