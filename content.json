[{"title":"mongo","date":"2017-01-10T10:36:07.000Z","path":"2017/01/10/mongo/","text":"mongose","tags":[{"name":"mongo","slug":"mongo","permalink":"http://nicewahson.github.io/tags/mongo/"}]},{"title":"crypto","date":"2017-01-06T07:59:36.000Z","path":"2017/01/06/crypto/","text":"crypto.getCiphers(),查看nodejs中能用的所有加密算法crypto.getHashes(),查看nodejs中能用的所有散列算法 dns模块dns.resolve(domain,[rrtype],callback),用于将一个域名解析为一组dns记录,callback为域名解析操作完成时调用的回调函数,function(err,addresses){}dns.lookup(domain,[family],callback),function(err,address,family){},family参数为4或6,表示获取到的ip地址类型为ip4或ip6dns.reverse(ip,callback),function(err,domains){},将ip反向解析为与该ip绑定的域名readline模块逐行读取流数据readline.createInterface(options),options对象中可以使用的{input:…,output:…,completer:function,terminal:boolean},completer用于指定tab补全处理 util模块format方法格式化debug(),error(),puts(),print(),log(string),log方法用于将一个字符串作为标准输出流进行输出,会在string之前加上当前时间输出util.inspect(object,[options]),返回一个字符串，串中包含了一个对象的信息util.isArray(object);util.isRegExp(object)util.isDate(object)判断是否为日期类型util.isError(object)判断是否为错误对象util.inherits(constructor,superConstructor)用于将一个父类的方法继承给该父类的子类","tags":[{"name":"crypto","slug":"crypto","permalink":"http://nicewahson.github.io/tags/crypto/"}]},{"title":"domain","date":"2017-01-04T10:15:59.000Z","path":"2017/01/04/domain/","text":"domain模块进行错误处理可以使用process.on(‘uncaughtException’,function(err){…})来捕获异常,单粗鲁，可能会资源泄漏，内存泄漏var domain = domain.create();返回一个domain对象，可以通过监听该对象的error事件并指定回调来实现当捕获到错误时的处理domain.on(‘error’,function(err){…}),使用domain的run方法指定domain对象监听的代码，这些代码要写在函数中，domain.run(fn)domain.add(emitter),可以对domain对象进行显示绑定domain.bind(callback),将一个回调函数与domain对象绑定，如果函数发生错误，交由domain对象domain.intercept(callback),和bind类似，区别是在bind的callback中要显示的throw error，而intercept不需要domain._stack查看domain堆栈中的内容domain.dispose(),销毁domain对象 assertassert.equal(actual,expected,[message]),参数：实际值，期望值，自定义异常信息,不相等会抛出assertionErrorassert.notEqual(…)…相等时会抛错assert.strictEqual(…)…,判断时连同类型一起判断,相当于===assert.ok(value,[message]),判断某个值是否为真assert.deepEqual(…)","tags":[{"name":"domain","slug":"domain","permalink":"http://nicewahson.github.io/tags/domain/"}]},{"title":"process","date":"2017-01-04T08:16:27.000Z","path":"2017/01/04/process/","text":"process.memoryUsage(),获取运行nodejs程序的进程的内存使用量。nextTick方法，用于将一个函数推迟到代码中所书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时调用,process.nextTick(callback)abort方法用于发出SIGABRT信号，使进程异常终止，同时产生一个核心文件chdir方法用于修改应用程序中使用的当前工作目录,process.chdir(directory),参数是一个字符串，相对或绝对路径cwd方法，返回当前目录exit方法用于退出nodejs应用程序进程,process,exit([code]),code指定为操作系统提供退出代码，为0时表示正常退出，默认为0getgid方法返回运行nodejs应用程序的进程组id，只在非windows系统有效setgid方法设置程序进程组id，只在非windows系统有效，process.setgid(id)getuid方法返回运行nodejs应用程序的进程的用户idsetuid。。。kill方法，向一个进程发送信号，process.kill(pid,[signal]),pid是进程号，signal可选，如SIGINT,SIGUSR1,默认为SIGTERM（表示中止该进程）uptime方法返回nodejs程序的当前运行时间，单位是秒。hrtime测试代码段的运行时间，返回一个数组，第一个参数是秒，第二个是毫秒child_process模块开启子进程child_process.spawn(command,[argv],[options])process.stdin.on(‘data’,function(data){}),process.stdout.write(data)开启子进程child_process.fork(modulePath,[args],[options])，使用此方法要显示关闭进程，process.exit(),发送消息可以使用process.send(m,[setHandle])当子进程收到消息时触发message事件，process.on(‘message’,function(m,[setHandle]){}),当发送时的setHandle为server或socket对象，那么收到时的也是。cluster.fork([env]),返回一个隐式创建的worker对象，表示使用fork方法开启的子进程中运行的nodejs应用程序实例对象，并且在该应用程序中运行一个模块文件，(默认是当前应用程序中使用的主模块文件)；cluster.on(‘fork’,function(worker){…});cluster.setupMaster([settings])修改子进程中运行的模块文件或修改子进程中运行的nodejs程序的其他默认行为","tags":[{"name":"process","slug":"process","permalink":"http://nicewahson.github.io/tags/process/"}]},{"title":"httpserver","date":"2016-12-24T02:59:16.000Z","path":"2016/12/24/httpserver/","text":"querystring.parse(str,[sep],[eq],[options]),str为转换的查询字符串,sep参数是该字符串中的分隔字符,默认为’&amp;’,eq是分配字符,默认为’=’,options是一个对象,可以在该对象中用一个整数类型的maxKeys属性指定转换后的属性个数,设置为0时等同于不使用maxKeysquerystring.stringify(obj,[sep],[eq]),作用和parse相反url.parse(urlStr,[parseQueryString]),将url字符串转换为一个对象,对象中有很多属性,比如query,为查询字符串,parseQueryString为布尔值,默认为false,为true时表示转换后的对象中的query字符串同时转换为对象url.format(urlobj),将url转换后的对象还原成字符串url.resolve(from,to),与path.resolve()方法类似response.writeHead(statusCode,[reasonPhrase],[headers]),第二个是状态码的描述信息,第三个是响应头response.write(chunk,[encoding]),encoding默认为utf8发送响应数据时，如果数据量过大或网络较慢，server会将数据缓存到内存中，然后在可以接收数据的时候将内存中的数据通过操作系统内核缓存区发送给对方write方法返回布尔值，为true时表示数据是直接发送到内核缓存区，为false表示先存到内存中。response.setTimeout(msecs,[callback]),设置响应超时时间，msecs是时间，callback是超时后的回调，如果不设置这个，或者不在timeout事件指定回调函数，那么当响应超时时会自动关闭与客户端连接的端口。var request = http.request(options,callback),options可以是字符串,如果是字符串,将自动使用url模块中的parse方法转换为一个对象。callback为function(response){}，表示获取到返回的响应流时调用的回调函数。每次调用request方法后，必须要加一个req.end()方法来结束本次请求。也可以直接使用http.get(options,callback),仅限于get方法，而且在结束请求时不需要手动调用end()","tags":[{"name":"http server","slug":"http-server","permalink":"http://nicewahson.github.io/tags/http-server/"}]},{"title":"net模块udpserver","date":"2016-12-21T10:00:23.000Z","path":"2016/12/21/net模块udpserver/","text":"net模块创建udp服务器udp协议是面向非连接的协议，不要求先建立连接，不安全但是速度快，更实时var dgram = require(‘dgram’);var net = dgram.createSocket(type,[callback]),type指定进行udp通信的协议类型，可为’udp4’或’udp6’,callback用于指定当从该端口接收到数据时调用的回调，function(msg,rinfo){…},msg是一个buffer对象，其中存放接收到的数据，rinfo参数是一个对象，所具有的属性 address:发送者的ip，family:标识发送者的ip是ipv4还是ipv6，port为发送者的socket端口号，size为发送者所发送的数据字节数，在从该socket端口中接收到数据时，触发message事件,所以也可以使用socket.on(‘message’,function(msg,ringo){})创建socket对象后，必须使用socket.bind(prot,[address],[callback],这样udp客户端才知道往哪个地址发数据，也可以不使用bind方法中的callback方法，绑定完后开始监听时触发socket.on(‘listening’,callback),指定当socket端口对象开始监听来自于指定地址和端口号的数据时所要执行的处理socket.send(buf,offset.length,port,address,[callback]),缓冲区，开始时的位置，发送的字节数，接受数据的socket端口对象所使用的端口号，地址，发送完毕的回调，function(err,bytes){…}socket.close()方法关闭该socket端口对象，停止从该端口上监听数据，如果此时应用程序不再执行其他代码，整个应用会正常关闭。当关闭时触发close事件.socket.setTTL(input),input为0-255的数字，设置数据包的生存时间。socket.setBroadcast(flag),布尔类型参数，为true时表示服务器或客户端可以利用socket对象的send方法进行广播","tags":[{"name":"tcp和udp通信","slug":"tcp和udp通信","permalink":"http://nicewahson.github.io/tags/tcp和udp通信/"}]},{"title":"tcp和udp通信","date":"2016-12-10T07:14:52.000Z","path":"2016/12/10/tcp和udp通信/","text":"net模块创建tcp服务器var net=require(‘net’),var server=net.createServer([options],[connectionListener]),connectionListener为function(socket){}是建立连接时的回调函数,socket是tcp服务器监听的socket端口对象server.listen(port,[host],[backlog],[callback]),port是端口号，为0时分配随机端口，tcp服务器会监听来自这个端口的连接，host是主机，忽略的话则监听任意ipv4的客户端连接，backlog指定位于等待队列中的客户端连接的最大数量，超过后tcp服务器将拒绝来自新的客户端请求，默认为511，服务器开始监听时触发listening事件，触发callback方法。server.address()查看服务器所监听的地址信息.server.getConnections(function(err,count){});方法获取当前连接数，可以设置服务器的最大连接数server.maxConnectionsserver.close([callback]),指定服务器拒绝所有新的客户端连接,当现有连接全部关闭时触发close事件，调用close方法server.on(‘close’,function(){…});socket.on(‘data’,function(data){…}),socket对象可以被用来读取客户端发送的流数据，每次接收到客户端发送的流数据时触发data事件，当收到另一侧传来的数据时触发socket.pipe(destination,[options]),destination为一个可用于写入流数据的对象,options是一个对象，可以在对象中使用一个布尔类型的end属性，如果属性为true，当数据读完时立即结束写操作，为false时不结束，可以被继续写入新数据，默认为truesocket.setEncoding(‘utf8’),设置读取到的数据的编码格式socket.on(‘error’,function(err){err.code…}),发生错误时触发此函数,同时,错误时应该调用socket.destroy()方法销毁该socket端口对象socket.end([data],[encoding]),服务端使用end关闭该客户端连接，客户端使用end关闭该服务端连接,data表示在关闭前向另一端追加发送的数据,可以是buffer，也可以是字符串创建tcp客户端var client = new net.Socket([options]),client.setEncoding(‘utf8’),client是一个socket对象,在需要往客户端或服务器传数据时，可以使用socket.write(data,[encoding],[callback]),callback是数据写入完毕时的回调，没有参数。client.end(‘end’),表示关闭连接时追加数据。socket.on(‘end’,function(){ server.unref(‘客户端连接关闭时关闭服务器’);})socket.on(‘close’,function(has_error){ if(has_error) server.unref(‘客户端连接关闭时关闭服务器’);});监听close事件，与server.close()方法不同。socket.setKeepAlive([enable],[initialDelay]),第一个参数表示是否启用探测机制，默认为false，第二个参数是探测间隔时间，隔多久探测一次对方机器，默认为0net.isIP(input),用于判断一个字符串是否是一个ip地址，不是ip的话返回0，是ipv4的话返回4，ipv6的话返回6net.isIPv4(input),判断字符串是否是一个ipv4地址net.isIPv6(input),判断是否是ipv6地址","tags":[{"name":"tcp和udp通信","slug":"tcp和udp通信","permalink":"http://nicewahson.github.io/tags/tcp和udp通信/"}]},{"title":"读写文件续","date":"2016-12-06T03:20:45.000Z","path":"2016/12/06/读写文件续/","text":"var fs=require(‘fs’); //同步读取，读取配置文件时可以使用fs.readFileSync(‘./index.html’,’utf-8’);fs.readFile(‘./index.html’,’utf-8’,function(err,data){ console.log(data);//操作完毕后打印结果 }) //异步读取fs.readFile(filename,[options],callback);如果不在options参数中指定encoding参数，那么读取的结果得到的是一个二进制buffer对象。options中可以用的属性,flag(以何种方式读或是写),encodingfs.writeFile(filename,data,[options],callback);options中可以用的属性，flag,mode(读写权限),encoding(可指定属性值为’utf-8’,’ascii’,’base64’,当data为buffer对象时该属性自动忽略)fs.appendFile(…),参数同上，在文件底部追加数据，和上面不同的是，options中的flag属性默认值为’a’,表示向文件底部追加，如果文件不存在，创建文件 从指定位置读写文件开始读写之前,先fs.open(filename,flags,[mode],function(err,fd){…}),fd是文件描述符然后fs.read(fd,buffer,offset,length,position,callback),参数： fd:open方法返回的文件描述符，buffer是一个Buffer对象，表示将文件数据读取到哪个缓冲区，offset指定向缓冲区写入数据时的开始写入位置，length参数用于指定从文件中读取的字节数，position用于指定读取文件时的开始位置(以字节为单位),callback指定,function(err,bytesRead,buffer){//bytesRead参数值代表实际读取的字节数，buffer为被读取的缓存区对象} 如果position为null,表示从当前位置开始继续读取(前一次读取的开始位置+字节数)，应该写在上一次read方法的回调里 write方法：fs.write(fd,buffer,offset,length,position,callback)buffer为被写入的缓冲区，offset为指定从缓冲区中读取数据时的开始位置，length为写入的字节数，position为写入文件时的开始位置，callback:function(err,written,buffer),written代表实际写入字节数position为null时，表示从当前位置开始继续写入。当想要向文件中追加数据时，需要在open方法中设置flag为’a’,只是一次的写入可以是’w’ 在写完之后，可以调用close方法，fs.close(fd,[callback]),callback中参数为err write方法是将数据写入到内存，再将内存中数据写入到文件，因此当写了一些数据，并不代表内存缓冲区中已经空了，可能还有数据，这时候调用close方法会有数据丢失的问题，这时候需要一个方法fs.fsync(fd,[callback])，文件同步操作,调用close方法后再进行调用将内存缓冲区的数据全部写到文件中 fs.mkdir(path,[mode],callback),path是被创建的目录的完整路径及目录名,callback是创建完成时的回调fs.readdir(path,callback),callback格式function(err,files){}fs.stat(path,callback),fs.lstat(path,callback),查看文件或目录信息,callback为function(err,stats),stats是一个fs.Stats对象检查文件或目录是否存在，fs.exists(path,callback),path是全路径,callback为function(exists){},exists是true或false获取文件或目录绝对路径，fs.realpath(path,[cache],callback),cache是一个对象，存放一些预先指定的路径,function(err,resolvedPath){},后一个参数是全路径var cache = {‘/etc’:’/private/etc’};fs.realpath(‘/etc/passwd’,cache,function(err,resolvedPath){}) 修改文件访问时间和修改时间fs.utimes(path,atime,mtime,callback),atime是指定修改后的访问时间,mtime是修改后的修改时间修改文件或目录的读写权限fs.chmod(path,mode,callback),chmod: user group other,read-write-excute移动文件或目录fs.rename(oldpath,newpath,callback),oldpath是被移动文件或目录的完整路径及文件或目录名，newpath是移动后的完整路径及文件或目录名截断文件fs.truncate(path,len,callback),len是截断后的文件大小(单位是字节数)删除空目录fs.rmdir(path,callback)监视文件或目录fs.watchFile(filename,[options],listener),文件名filename，options是一个对象，可以用一个persistent:true(false)表示指定当指定了被监视的文件后是否停止当前正在运行的程序，也可以是interval:xxx，整数，表示多少时间监视一次,callback为function(curr,prev){}fs.unwatch(filename,[listener]),取消监视ReadStream读取文件fs.createReadStream(path,[options]),返回一个file文件输入流,在这里对其添加事件回调var file = fs.createReadStream(‘./a.txt’,{start:3,end:12});file.on(‘open’,function(fd){console.log(‘文件打开’)});file.on(‘data’,function(data){console.log(‘文件读到数据’)});WriteStream写入文件var out = fs.createWriteStream(path,[options])，返回一个输出流，out.write(data,[encoding],[callback]),该方法返回一个bool值，表示缓存区中是否已经满，满了为false复制文件方法pipe(destination,[options]),destination是写入流数据的对象，options对象中可以使用一个end属性，为true的话表示读完数据后关闭文件，false的话则不关闭，还可以继续写入，默认为true path模块normalize(path)将非标准路径字符串转换为标准字符串join([path1],[path2]…),将多个参数值字符串结合为一个路径字符串resolve解析路径relative(from,to)获取两个相对路径之间的关系dirname(path),获取路径中的目录名basename(path,[ext]),获取路径中的文件名，path为完整路径，ext为可选参数，用于在方法返回的文件名中去除该文件的扩展名extname(path),获取文件扩展名","tags":[{"name":"文件操作","slug":"文件操作","permalink":"http://nicewahson.github.io/tags/文件操作/"}]},{"title":"读写文件","date":"2016-11-21T10:33:07.000Z","path":"2016/11/21/读写文件/","text":"var fs=require(‘fs’); //同步读取，读取配置文件时可以使用fs.readFileSync(‘./index.html’,’utf-8’);fs.readFile(‘./index.html’,’utf-8’,function(err,data){ console.log(data);//操作完毕后打印结果 }) //异步读取fs.readFile(filename,[options],callback);如果不在options参数中指定encoding参数，那么读取的结果得到的是一个二进制buffer对象。options中可以用的属性,flag(以何种方式读或是写),encodingfs.writeFile(filename,data,[options],callback);options中可以用的属性，flag,mode(读写权限),encoding(可指定属性值为’utf-8’,’ascii’,’base64’,当data为buffer对象时该属性自动忽略)fs.appendFile(…),参数同上，在文件底部追加数据，和上面不同的是，options中的flag属性默认值为’a’,表示向文件底部追加，如果文件不存在，创建文件从指定位置读写文件开始读写之前,先fs.open(filename,flags,[mode],function(err,fd){…}),fd是文件描述符然后fs.read(fd,buffer,offset,length,position,callback),参数： fd:open方法返回的文件描述符，buffer是一个Buffer对象，表示将文件数据读取到哪个缓冲区，offset指定向缓冲区写入数据时的开始写入位置，length参数用于指定从文件中读取的字节数，position用于指定读取文件时的开始位置(以字节为单位),callback指定,function(err,bytesRead,buffer){//bytesRead参数值代表实际读取的字节数，buffer为被读取的缓存区对象}","tags":[{"name":"文件操作","slug":"文件操作","permalink":"http://nicewahson.github.io/tags/文件操作/"}]},{"title":"nodejs_buff","date":"2016-11-21T09:46:22.000Z","path":"2016/11/21/node_buffer/","text":"构造buffernew Buffer(size),size为缓存区大小buf.fill(value,[offset],[end]),此方法对buffer进行初始化,value必填，表示需要被写入的数值，第二个参数表示从第几个参数写入，默认为0，第三个参数表示写入到第几个字节处，默认为buffer对象大小，即书写到缓存区底部new Buffer(array),array是指定数值数组 eg: newBuff([1,2,3])//(Buffer 00 01 02)new Buffer(str,[encoding]),缓冲区中存放的是原字符串的十六进制表现形式，使用字符串初始化缓冲区，第二个参数为指定文字进行编码，不同编码字符串生成缓冲区对象，ascii编码和u8编码生成的是相同的，其他的是不同的，也就会把不同的数据放在缓冲区。缓冲区对象存在length属性，可以获取长度，也可以使用下标形式获取制定位置的值。 Buffer对象与字符串对象相互转换toString方法，buf.toString([encoding],[start],[end]),第一个参数默认u8，二三表示转换的起始终止位置write方法向已创建buffer对象写入字符串，buf.write(string,[offset],[length],[encoding]),第一个参数指定写入内容，offset和length参数指定字符串转为字节数据后的写入位置，offset是下标。书写位置从第1+offset个字节开始到offset+length个字节为止。第四个参数编码默认u8。StringDecoder对象var StringDecoder=require(‘string_decoder’).StringDecoder;decoder=new StringDecoder([encoding]);encoding默认u8decoder.write(buffer);将buffer对象中的数据转为字符串 Buffer对象和JSON对象转换JSON.stringify方法将buffer对象中保存的数据转换为一个字符串，再用JSON.parse方法将转换后的字符串还原为一个数组，这个数组可以用来构造Buffer对象 复制缓存数据，将一个buffer对象中以保存的二进制数据复制到另一个buffer对象中。buf.copy(targetBuffer,[targetStart],[sourceStart],[sourceEnd]),a.copy(b,10),一直复制到b的末尾，不会再继续复制。 Buffer的类方法isBuffer方法判断一个对象是否是一个Buffer对象，Buffer.isBuffer(obj)byteLength用于计算指定字符串的字节数，Buffer.byteLength(string,[encoding])concat方法将多个buffer对象连接起来，Buffer.concat(list,[totalLength]),list代表多个buffer对象形成的数组，第二个参数用于指定拼接后生成的buffer对象的长度isEncoding方法用于检测一个字符串是否是一个有效的编码格式字符串，Buffer.isEncoding(encoding);","tags":[{"name":"nodejs buffer","slug":"nodejs-buffer","permalink":"http://nicewahson.github.io/tags/nodejs-buffer/"}]}]