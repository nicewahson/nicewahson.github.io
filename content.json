[{"title":"关于serInterval","date":"2018-05-16T08:59:55.000Z","path":"2018/05/16/关于serInterval/","text":"serInterval()表示以一定时间间隔去循环回调，指定的是’开始执行’之间的时间间隔，不考虑每次循环本身的时间。setInterval和serTimeout都表示的异步macroTask，也就是说在主线程空闲时候，如果时间到的话就去开始执行回调。对于serInterval，设定时间大于每次循环的时间，不会有问题；如果每次task的时间超出了指定时间间隔的话，就会有问题 对于浏览器来说，浏览器会在时间间隔后持续向eventloop中加入task，就是说不管当次执行要多久，如果间隔100ms，当次循环需要200ms的话，那么队列里就存在有两个连续执行的任务,会进行累积。比如说设置100ms，第一次循环要5ms，那么再过95ms就会开始执行下一次；而如果第一次循环要105ms，下一次循环就会立即开始。 setInterval(function(){ console.log(2); },1000); (function (){ sleeping(3000); })() 等到第二行语句运行完成以后，立刻连续输出三个2，然后开始每隔1000毫秒，输出一个2。也就是说，setIntervel具有累积效应，如果某个操作特别耗时，超过了setInterval的时间间隔，排在后面的操作会被累积起来，然后在很短的时间内连续触发，这可能或造成性能问题（比如集中发出Ajax请求） 但是对于nodejs来说，就不会发生累积。setInterval 在准备把回调函数加入到事件队列的时候，会判断队列中是否还有未执行的回调，如果有的话，它就不会再往队列中添加回调函数 var count = 0; var countId = setInterval(function() { if(count >= 5){ clearInterval(countId) } count++; console.log(2+ \" time: \" +Date.now()); }, 1000); (function() { var start = Date.now(); for(var i=1; i&lt;=200000000;i++){ if(i===200000000){ console.log(i); } }; console.log(Date.now() - start); })(); 200000000 1771 2 time: 1457495719375 2 time: 1457495720378 2 time: 1457495721380 2 time: 1457495722383 2 time: 1457495723395 2 time: 1457495724397 [Finished in 8.5s] 可以看到，主线程占用时间长的话，后续的任务会被延迟执行。 var count = 0; var countId = setInterval(function() { if(count == 0){ (function() { var start = Date.now(); for(i=1; i&lt;=200000000;i++){ // (md里面 小于号 & lt; 大于号 & gt;) if(i==200000000){ console.log(i); } } console.log(Date.now() - start); })(); } if(count >= 5){ clearInterval(countId) } count++; console.log(2+ \" time: \" +Date.now()); }, 200); 浏览器下: 200000000 VM1649:12 466 VM1649:19 2 time: 1526464501571 VM1649:19 2 time: 1526464501572 VM1649:19 2 time: 1526464501705 VM1649:19 2 time: 1526464501905 VM1649:19 2 time: 1526464502105 VM1649:19 2 time: 1526464502305 nodejs下： 200000000 447 2 time: 1526464483584 2 time: 1526464483784 2 time: 1526464483985 2 time: 1526464484186 2 time: 1526464484387 2 time: 1526464484588 可以看到，当第一次循环所需时间比间隔时间长的话，浏览器环境下会持续不断按实际间隔加回调，同时第一次的执行时间直接导致后面的执行时间往后推，第一次的时间=第二次时间，第二次时间+133=第三次时间，466-400=66，加上133正好是200。就是说浏览器下所有的回调首先按固定时间间隔排好，如果某次回调执行时间长于间隔时间的话，就会把导致下次乃至更下次的回调执行时间往后推迟。这样就可能导致两次回调不存在时间间隔的情况。 而nodejs下则不会这样。 对于上面这种不存在时间间隔的情况，可以改用setTimeout来解决，即在上面回调结束后指定时间继续下次的回调。 setTimeout(function f() { //处理中 ... setTimeout(f, interval); }, interval); https://jeffjade.com/2016/01/10/2016-01-10-javaScript-setInterval/ http://www.laruence.com/2009/09/23/1089.html","tags":[{"name":"js","slug":"js","permalink":"http://nicewahson.github.io/tags/js/"}]},{"title":"string和array的api","date":"2018-04-13T01:55:04.000Z","path":"2018/04/13/string和array的api/","text":"String.prototype.replacestring.replace: function(regexp, replacement) regexp可以使用/g修饰符。 replacement可以是字符串，也可以是$符号用来指代替换内容。 $&:代指匹配到的内容本身 $`:代指匹配到的结果前面的文本(前面所有) $':代指匹配到的结果后面的文本 $n:代指匹配到的第n组内容 $$:指美元符号 'msaTom'.replace(/[A-Z]|^ms/g,'-$&') // \"-msa-Tom\" 'qwersaTom'.replace(/[A-Z]|^ms/g,'-$`') // \"qwersa-qwersaom\" replacement也可以是函数，function(match, $1, $2,..., index, string){} match是匹配到的内容，$n指分组，有多少分组就有多少$，最后的index指内容的起始下标，string指原字符串。 'qqqaaa'.replace(/(q)(a)/g,function(m,s1,s2,index,str){ console.log(m,s1,s2,index, str) return 'w'; }) // qa q a 2 qqqaaa Array.prototype.splicesplice可以是 添加 删除 替换 splice(index, deleteCount, …) 从index位置开始 删除deleteCount个元素 再添加后面的参数 var arr = [2,3,4]; arr.splice(1,0,6,7,8) arr // [2,6,7,8,3,4] 从下标1开始 删除0个元素 添加后面的6 7 8 arr.splice(1,2,6,7,8) arr // [2,6,7,8] 从下标1开始 删除2个 添加后面的6 7 8","tags":[{"name":"javascript api","slug":"javascript-api","permalink":"http://nicewahson.github.io/tags/javascript-api/"}]},{"title":"flex布局","date":"2018-04-11T02:52:52.000Z","path":"2018/04/11/flex布局/","text":"flex容器属性flex-direction: row | row-reverse | column | column-reverse flex-wrap: nowrap | wrap | wrap-reverse flex-flow: 上两个属性简写 flex-direction flex-wrap justify-content: 主轴对齐方式 flex-start | flex-end | center | space-between | space-around align-items: 交叉轴对齐方式 flex-start | flex-end | center | baseline(第一行文字基线对齐) | stretch(如果项目未设置高度或设为auto，将占满整个容器的高度) align-content: 多行元素对齐方式 flex-start | flex-end | center | space-around | space-between | stretch 和上一个属性区别就是这个是处理多行的，所以对于单行这个属性无效。 项目属性order: integer 排序 默认为0 越小越靠前排列 flex-grow: integer 放大比例 默认为0，存在剩余空间也不放大；如果剩余空间为 x，三个元素的 flex-grow 分别为 a，b，c。设 sum 为 a + b + c。那么三个元素将得到剩余空间分别是 x a / sum, x b / sum, x * c / sum。 父元素宽度 500px，三个子元素的 width 分别为 100px，150px，100px。 于是剩余空间为 150px 三个元素的 flex-grow 分别是 1，2，3，于是 sum 为 6 则三个元素所得到的多余空间分别是： 150 * 1 / 6 = 25px 150 * 2 / 6 = 50px 150 * 3 / 6 = 75px 三个元素最终的宽度分别为 125px，200px，175px。 100px + 25px = 125px 150px + 50px = 200px 100px + 75px = 175px 如果所有项目都为1，那么这些项目将平分容器宽度。其中一个为2，其他为1的话，为2的占据的剩余空间宽度将是其它的2倍。注意，这里说的是剩余空间，也就是项目排完后多出来的空间。如果所有项目都是0-1，全部之和加起来小于1的话，还有剩余的不再分配。 flex-shrink: 项目缩小比例 默认为1，如果空间不足(所有项目宽度之和大于容器宽度)，项目将缩小；如果其中一个为0，其它为1，那为0的将不缩小。 超过宽度为x，三个flex-shrink为a,b,c，宽度为wa,wb,wc，那么最终的缩小尺寸为 a b c和大于1： x*wa*a/(wa*a+wb*b+wc*c) x*wa*a/(wa*a+wb*b+wc*c) x*wa*a/(wa*a+wb*b+wc*c) 当a b c和小于1，x=x*(a+b+c),然后和上面一样 假设父元素 500px。三个子元素分别设置为 150px，200px，300px。 比如说三个子元素的 flex-shrink 的值分别为 1，2，3。 首先，计算子元素溢出多少：150 + 200 + 300 - 500 = -150px。 那这 -150px 将由三个元素的分别收缩一定的量来弥补。 具体的计算方式为：每个元素收缩的权重为其 flex-shrink 乘以其宽度。 所以总权重为 1 150 + 2 200 + 3 * 300 = 1450 三个元素分别收缩： 150 1(flex-shrink的值) 150(width) / 1450 = -15.5 150 2(flex-shrink的值) 200(width) / 1450 = -41.4 150 3(flex-shrink的值) 300(width) / 1450 = -93.1 三个元素的最终宽度分别为： 150 - 15.5 = 134.5 200 - 41.4 = 158.6 300 - 93.1 = 206.9 同样，当所有元素的 flex-shrink 之和小于 1 时，计算方式也会有所不同： 此时，并不会收缩所有的空间，而只会收缩 flex-shrink 之和相对于 1 的比例的空间。 上面的例子，但是 flex-shrink 分别改为 0.1，0.2，0.3。于是总权重为 145。 三个元素收缩总和并不是 150px，而是只会收缩 150px 的 (0.1 + 0.2 + 0.3) / 1 即 60% 的空间：90px。 每个元素收缩的空间为： 90 0.1(flex-shrink) 150(width) / 145 = 9.31 90 0.2(flex-shrink) 200(width) / 145 = 24.83 90 0.3(flex-shrink) 300(width) / 145 = 55.86 三个元素的最终宽度分别为： 150 - 9.31 = 140.69 200 - 24.83 = 175.17 300 - 55.86 = 244.14 这里是原文 flex-basis: 项目伸缩基准值。默认为auto。 number|auto|initial|inherit 未指定时，值为width；width没指定时，值为content宽。受项目maxwidth和minwidth影响。同时当空间不足时或有剩余，就会按照flex-grow和flex-shrink。 flex: flex-grow flex-shrink flex-basis;三个值缩写 默认为0 1 auto;后两个属性可选。所以直接写flex:1和flex-grow:1是一样的。 flex: auto == flex:1 1 auto flex: none == flex:0 0 auto align-self: auto | flex-start | flex-end | baseline | center | stretch 项目单独的交叉轴对齐方式，可覆盖align-items属性。默认为auto，表示继承align-items值。 https://zhuanlan.zhihu.com/p/24372279http://www.ruanyifeng.com/blog/2015/07/flex-grammar.htmlhttps://blog.csdn.net/sinat_27088253/article/details/51532992https://zhuanlan.zhihu.com/p/21834559","tags":[{"name":"css flex","slug":"css-flex","permalink":"http://nicewahson.github.io/tags/css-flex/"}]},{"title":"关于Date对象","date":"2018-04-09T05:54:09.000Z","path":"2018/04/09/关于Date对象/","text":"1.构造函数直接调用无效，即使传参。 2.new进行构造时 new Date(); new Date(value); new Date(dateString); new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]); 年：使用四位数年份，比如2000。如果写成两位数或个位数，则加上1900，即10代表1910年。如果是负数，表示公元前。 月：0表示一月，依次类推，11表示12月。 日：1到31。 小时：0到23。 分钟：0到59。 秒：0到59 毫秒：0到999。 // 参数为时间零点开始计算的毫秒数 new Date(1378218728000) // Tue Sep 03 2013 22:32:08 GMT+0800 (CST) // 参数为日期字符串 new Date('January 6, 2013'); // Sun Jan 06 2013 00:00:00 GMT+0800 (CST) // 参数为多个整数， // 代表年、月、日、小时、分钟、秒、毫秒 new Date(2013, 0, 1, 0, 0, 0, 0) // Tue Jan 01 2013 00:00:00 GMT+0800 (CST) * 参数可以是负数，代表1970年元旦之前的时间 new Date(-1378218728000) // Fri Apr 30 1926 17:27:52 GMT+0800 (CST) * 只要是能被Date.parse()方法解析的字符串，都可以当作参数 new Date('2013-2-15') new Date('2013/2/15') new Date('02/15/2013') new Date('2013-FEB-15') new Date('FEB, 15, 2013') new Date('FEB 15, 2013') new Date('Feberuary, 15, 2013') new Date('Feberuary 15, 2013') new Date('15 Feb 2013') new Date('15, Feberuary, 2013') // Fri Feb 15 2013 00:00:00 GMT+0800 (CST) 日期类型相加时返回两个字符串连接后的新字符串，相减时返回间隔毫秒数。 Date.now() Date.now方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000 Date.parse()1234567new Date().getDay() // 返回星期几getDate() // 返回几号new Date().setDate(num); // num是整数，表示设置为一个月的几号，为1就是设置为当月的1号 0就是上个月的最后一天getMonth() // 返回month 从0开始 所以真实月份要+1","tags":[{"name":"api Date","slug":"api-Date","permalink":"http://nicewahson.github.io/tags/api-Date/"}]},{"title":"git命令小结","date":"2018-04-08T17:17:44.000Z","path":"2018/04/09/git命令小结/","text":"添加子公共项目：git remote add childUpstream https://xxxxgit subtree –prefix -S=放子git工程的文件夹 childUpstream 分支 git rebase, git mergemerge之前在master上merge，根据696和8ab和两个分支的共同祖先e38进行三方合并，最后生成新commit rebase之前在master上git rebase dev，会把rebase的分支上内容拉下来，再把本次master上特有的全部commit都提取出来顶到最上面，生成新的commit，每个commit有一个冲突，也就可能多次冲突。相当于把master上的commit复制一遍到了dev上，但是还是处在master分支。","tags":[{"name":"git 版本","slug":"git-版本","permalink":"http://nicewahson.github.io/tags/git-版本/"}]},{"title":"jquery的理解","date":"2018-03-21T09:42:39.000Z","path":"2018/03/21/jquery的理解/","text":"这样的话，要给jquery提供额外的方法，就可以将其挂在jquery.fn上。","tags":[]},{"title":"css的选择器*=,|=, ~=,$=","date":"2018-03-21T09:30:43.000Z","path":"2018/03/21/关于几个css的选择器/","text":"这里","tags":[]},{"title":"记一次bootstrap的bug","date":"2018-03-21T02:53:28.000Z","path":"2018/03/21/记一次bootstrap的bug/","text":"换了个环境后，现在用的是jquery和bootstrap，jquery属于半吊子水平，所以碰到问题不知道怎么百度啊，只能去翻翻源码(当然不一定看得懂)。 情况是这样的：对表单有个校验，用的是bootstrapValidator做的。这个validator是要求所有要校验的。","tags":[{"name":"jquery","slug":"jquery","permalink":"http://nicewahson.github.io/tags/jquery/"}]},{"title":"新年小记","date":"2018-02-23T02:53:37.000Z","path":"2018/02/23/新年小记/","text":"过年。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://nicewahson.github.io/tags/随笔/"}]},{"title":"当fetch遇见CORS","date":"2018-02-23T02:40:07.000Z","path":"2018/02/23/当fetch遇见CORS/","text":"最近做了一个无头浏览器phantomjs截微信文章的功能，最后拆出了三个功能，一个是把整篇文章下载成一张长图，一个是把长图切成小图然后全部上传到后台再返回全部的图片地址，再一个就是看不见的直接把这些图片链接全部上传到已有的接口。下载图片无非就是把phantomjs截下来的图保存到本地，然后再用nodejs去读图下载图，关键代码就这点 var stm = fs.createReadStream(‘./page/‘ + outfiles[0]).pipe(resp);stm.on(‘finish’, function () { //在pipe结束后再删除，否则pipe出来的会缺失 console.log(‘finish success’) fs.unlinkSync(‘./page/‘ + outfiles[0])})然后是切图上传小图。这步结束后，上传所有图片链接时就出了点问题。 先说一下，node中间层和前台是不同域的，所以先要上CORS配置 res.setHeader(“Access-Control-Allow-Origin”, “*”);//res.setHeader(“Access-Control-Allow-Origin”, req.headers.origin);//res.setHeader(“Access-Control-Allow-Headers”, “X-Requested-With,token, tookie”);res.setHeader(“Access-Control-Allow-Methods”, “PUT,POST,GET,DELETE,OPTIONS”);res.setHeader(“X-Powered-By”, ‘ 3.2.1’);允许所有请求来源和请求方式。上面有一个OPTIONS请求，这个是prelight，也就是预检请求。这里要再记一下简单请求和非简单请求，因为浏览器再发起非简单请求时，会先发一个预检请求，也就是OPTIONS请求方式的 请求方法是以下三种方法之一： HEAD GET POST HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 上面这些条件，只要有一个不满足，那就是非简单请求，就会发OPTIONS，点这里了解更多。 前台使用的是fetch进行请求处理，因为后台处理图片链接的接口是需要cookie的，由于cookie是在后台服务器生成的，而且node起的服务是单独部署的，所以作为中间层的node是无法直接获取到cookie的(不是同一个域)，也就是说，即使是fetch里面添加了 credentials: ‘include’也是没用的。 再一个，当fetch时添加了credentials的话，就会出现遇见请求失败，origin设置为*不允许，原因在这里，所以就有了第二种的req.headers.origin。","tags":[{"name":"fetch,cors","slug":"fetch-cors","permalink":"http://nicewahson.github.io/tags/fetch-cors/"}]},{"title":"scrollIntoview介绍","date":"2017-10-28T07:48:56.000Z","path":"2017/10/28/scrollIntoview介绍/","text":"scrollIntoView最近看到一些自写的滚动效果，然后想起了scrollInfoView这个api，就又拿出来搞一番。 MDN官方上说这个功能是实验性阶段，不谈移动端，但是看了看caniuse还是一片绿(不喜欢) 主要语法： element.scrollIntoView()//相当于scrollIntoView(true) element.scrollIntoView(Boolean)//参数为true的话，元素顶端和所在可视区的顶端平齐， 为false的话元素底端和所在可视区的底端对齐 element.scrollIntoView(scrollIntoViewOptions); // Object型参数，可选值有 { behavior: \"auto\" | \"instant\" | \"smooth\",//立即滚动和平滑滚动 block: \"start\" | \"end\", 不加这个属性的话，滚动位置是在可视区中间。加start的话，就和上一个true效果一样 } 效果可以去这里看看然后，搞事的来了。 scrollIntoViewIfNeeded和上面的一样，也是来进行元素滚动的，但是有点小区别，上面的当元素在可视区时，还是会进行指定的滚动，而这个只有元素不在可视区才会进行滚动。不过用法上还是很简单的 element.scrollIntoViewIfNeeded()//也是相当于默认传了个true element.scrollIntoViewIfNeeded(Boolean)// 参数是boolean值，为true的话，元素滚动后的位置在可视区正中；为false的话，就是元素离 可视区上下边缘哪个近，就停在哪个位置，就是说上面的元素要滚下来，最后就停在可视区上 面，下面元素要滚上去，就停在可视区下面 卒~","tags":[]},{"title":"react-redux之connect","date":"2017-10-27T01:20:00.000Z","path":"2017/10/27/react-redux之connect/","text":"connect代码比较多，抽象，慢慢看 export function createConnect({ connectHOC = connectAdvanced, mapStateToPropsFactories = defaultMapStateToPropsFactories, mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories, mergePropsFactories = defaultMergePropsFactories, selectorFactory = defaultSelectorFactory } = {}) { return function connect( mapStateToProps, mapDispatchToProps, mergeProps, { pure = true, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, ...extraOptions } = {} ) { const initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps') const initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps') const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps') return connectHOC(selectorFactory, { // used in error messages methodName: 'connect', // used to compute Connect's displayName from the wrapped component's displayName. getDisplayName: name => `Connect(${name})`, // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes shouldHandleStateChanges: Boolean(mapStateToProps), // passed through to selectorFactory initMapStateToProps, initMapDispatchToProps, initMergeProps, pure, areStatesEqual, areOwnPropsEqual, areStatePropsEqual, areMergedPropsEqual, // any extra options args can override defaults of connect or connectAdvanced ...extraOptions }) } } export default createConnect() import hoistStatics from 'hoist-non-react-statics' // 自动把所有绑定在对象上的非react方法都绑定到新的对象上","tags":[{"name":"react-redux","slug":"react-redux","permalink":"http://nicewahson.github.io/tags/react-redux/"}]},{"title":"html学习","date":"2017-10-26T01:23:01.000Z","path":"2017/10/26/html学习/","text":"","tags":[]},{"title":"vue简单记","date":"2017-10-26T01:22:22.000Z","path":"2017/10/26/vue简单记/","text":"定义组件时使用的标签名中不能有大写字母，而且如果全局注册的组件，必须在挂载元素实例化之前注册，否则会报do you register component correctly? 组件的标签名一定要写完整，，要是这种形式，如果只是这样的形式，会出现只渲染出第一个组件的情况，因为组件不知道什么时候结束。 slot用来进行内容填充，在组件中定义时用xxx这种形式，如果不指定name属性的话，在上面使用的时候，组件里面的内容会替换全部的slo(但是这种多个slot不带name会报错)；如果是指定的name属性，比如xxxx，这样的组件里的填充内容只会替换掉组件定义时指定name的slot，相当于插槽的意思。 vm.$el 元素 vm.$data data数据 vm.$mount vm.$destroy手动挂载销毁 vm.$options 除data外的属性 使用template作模板标签，将标签整个放到挂载元素外面就不会被渲染，放在里面的话，就会直接渲染出template里面的内容。 使用$emit向父组件进行传值，需要先注册一个事件，然后手动出发this.$emit(事件名，参数1，参数2…)","tags":[{"name":"vue","slug":"vue","permalink":"http://nicewahson.github.io/tags/vue/"}]},{"title":"react-redux源码初窥之Provider","date":"2017-10-25T01:20:00.000Z","path":"2017/10/25/react-redux源码初窥之Provider/","text":"redux提供了一个独立的store，但是它并不是完全为了react定做的，要想在react中使用redux，需要自己写store.getstate,subscribe…，所以，为了能将redux完全应用到react而减少我们的代码，就有了react-redux Provider // Provider是这么用的，所以它是个react组件，有个prop是store /***/ export const subscriptionShape = PropTypes.shape({ trySubscribe: PropTypes.func.isRequired, tryUnsubscribe: PropTypes.func.isRequired, notifyNestedSubs: PropTypes.func.isRequired, isSubscribed: PropTypes.func.isRequired, }) export const storeShape = PropTypes.shape({ subscribe: PropTypes.func.isRequired, dispatch: PropTypes.func.isRequired, getState: PropTypes.func.isRequired }) let didWarnAboutReceivingStore = false function warnAboutReceivingStore() { if (didWarnAboutReceivingStore) { return } didWarnAboutReceivingStore = true warning( ' does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.' ) } 有一个在react中组件跨层级传递状态的办法，就是使用context，比如说有个顶层组件是List，这个组件中有个ListItem,在里面还有个Button里想要使用最顶层List中的state，比如说叫color，传统的方法只能是通过props来进行一级级的传递，使用context就不一样了。要用它，先在List组件中声明一个List.childContextTypes={color: React.PropTypes.string}，然后要在List中写一个方法, getChildContext(){return color: ‘red’}，在顶层组件做的事就行了，然后在最底层的Button组件里面要用它， Button.contextTypes = {color: React.PropTypes.string}，这样声明完成后，Button组件里就可以通过this.context.color来使用这个color。 export default class Provider extends Component { getChildContext() { return { store: this.store, storeSubscription: null } } constructor(props, context) { super(props, context) this.store = props.store } render() { //表示this.props.children只能是一个大的组件，也就是一个根结点 return Children.only(this.props.children) } } if (process.env.NODE_ENV !== 'production') { // 这里来判断，组件挂载后可以对store中的state进行修改，但是不能直接改变store这个对象本身。 Provider.prototype.componentWillReceiveProps = function (nextProps) { const { store } = this const { store: nextStore } = nextProps if (store !== nextStore) { warnAboutReceivingStore() } } } Provider.propTypes = { store: storeShape.isRequired, children: PropTypes.element.isRequired } Provider.childContextTypes = { store: storeShape.isRequired, storeSubscription: subscriptionShape } Provider.displayName = 'Provider'","tags":[{"name":"react-redux","slug":"react-redux","permalink":"http://nicewahson.github.io/tags/react-redux/"}]},{"title":"redux源码学习","date":"2017-10-14T01:19:00.000Z","path":"2017/10/14/redux源码学习/","text":"部分理解redux真的是有利于理解函数式编程，遍地都是函数，遍地都很抽象，以下的是部分理解： 先看一眼redux整个文件夹的目录 基本上用到的也都在这几个里面了先是createstore export var ActionTypes = { INIT: '@@redux/INIT' }; export default function createStore(reducer, preloadedState, enhancer) { //一整个大的函数，所有的其他函数和变量声明调用都在这个里面，避免全局污染。 var _ref2; // enhancer意思是增强，这里就表示增强store，主要作用一般是对store进行封装加工。典型的就是applimiddleware中的使用，将createstore整个方法给传过去，那边就可以获取到这个store。 /* const store = createStore( combineReducers(reducers), compose(applyMiddleware(...middlewares)) ); */ //可以传两个或三个参数，两个参数的话进行重新赋值，保证第三个参数始终是个增强函数 if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') { enhancer = preloadedState; preloadedState = undefined; } if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.'); } return enhancer(createStore)(reducer, preloadedState); } if (typeof reducer !== 'function') { throw new Error('Expected the reducer to be a function.'); } var currentReducer = reducer; //如果从外面传的话，就会传到这里，不传或者类型为function的话这里就是UNdefined var currentState = preloadedState; var currentListeners = []; var nextListeners = currentListeners; var isDispatching = false; //这个方法有点疑惑，没理解？？@@ function ensureCanMutateNextListeners() { if (nextListeners === currentListeners) { nextListeners = currentListeners.slice(); } } function getState() { return currentState; } //进行订阅，参数是函数，表示发布的事件发生时的处理，返回值是个函数，直接调用的话就是将这一个listener移除。 function subscribe(listener) { if (typeof listener !== 'function') { throw new Error('Expected listener to be a function.'); } var isSubscribed = true; ensureCanMutateNextListeners(); nextListeners.push(listener); return function unsubscribe() { if (!isSubscribed) { return; } isSubscribed = false; ensureCanMutateNextListeners(); var index = nextListeners.indexOf(listener); nextListeners.splice(index, 1); }; } // 发出action function dispatch(action) { //action要是简单对象 if (!isPlainObject(action)) { throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.'); } //action必须有个type类型来进行区分，约定。 if (typeof action.type === 'undefined') { throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?'); } if (isDispatching) { throw new Error('Reducers may not dispatch actions.'); } try { isDispatching = true; //currentReducer是由外部传进来的函数，里面是对整个state和发出的action进行处理生成新的state currentState = currentReducer(currentState, action); } finally { isDispatching = false; } //dispatch是同步执行的，执行完通知所有listener执行。 var listeners = currentListeners = nextListeners; for (var i = 0; i < listeners.length; i++) { listeners[i](); } return action; } //替换reducer处理函数，但是没看到有具体的用法。 function replaceReducer(nextReducer) { if (typeof nextReducer !== 'function') { throw new Error('Expected the nextReducer to be a function.'); } currentReducer = nextReducer; dispatch({ type: ActionTypes.INIT }); } // 这个方法后续研究。 function observable() { var _ref; var outerSubscribe = subscribe; return _ref = { subscribe: function subscribe(observer) { if (typeof observer !== 'object') { throw new TypeError('Expected the observer to be an object.'); } function observeState() { if (observer.next) { observer.next(getState()); } } observeState(); var unsubscribe = outerSubscribe(observeState); return { unsubscribe: unsubscribe }; } }, _ref[$$observable] = function () { return this; }, _ref; } //初始化一个action dispatch({ type: ActionTypes.INIT }); return _ref2 = { dispatch: dispatch, subscribe: subscribe, getState: getState, replaceReducer: replaceReducer }, _ref2[$$observable] = observable, _ref2; } 上面有个currentReducer函数，表示的是一个reducer函数，当然，如果是直接传一个reducer函数进来的话，返回一个state，那么这个store只有这一个state，getstate方法返回的也是这个值；如果是多个reducer函数进行组合的话，返回的就是一个大的state树，正常来讲都是用combineReducer来进行多个state的组合，下面上它: //reducer可用性判断 function assertReducerSanity(reducers) { Object.keys(reducers).forEach(function (key) { var reducer = reducers[key]; var initialState = reducer(undefined, { type: ActionTypes.INIT }); //reducer函数要给一个初始状态，不能是undefined if (typeof initialState === 'undefined') { throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.'); } //tostring(36)是36进制，这里感觉是和上面的功能一样，不过type是个随机的@@ var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.'); if (typeof reducer(undefined, { type: type }) === 'undefined') { throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.'); } }); } //新旧state进行比较判断 function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) { var reducerKeys = Object.keys(reducers); var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer'; if (reducerKeys.length === 0) { return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.'; } if (!isPlainObject(inputState)) { return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"'); } //初始化store时传进来的inputstate是{}，inputstate的keys为空，就不会进行这一步；当整个state进行构造完成后，对下一次的新旧state进行比较，在新的里面出现了旧state没有的，就会有提示了 var unexpectedKeys = Object.keys(inputState).filter(function (key) { return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]; }); unexpectedKeys.forEach(function (key) { unexpectedKeyCache[key] = true; }); if (unexpectedKeys.length > 0) { return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.'); } } export default function combineReducers(reducers) { //将多个reducer进行组合，很明显，reducers是个对象 var reducerKeys = Object.keys(reducers); var finalReducers = {}; for (var i = 0; i < reducerKeys.length; i++) { var key = reducerKeys[i]; if (process.env.NODE_ENV !== 'production') { if (typeof reducers[key] === 'undefined') { warning('No reducer provided for key \"' + key + '\"'); } } //只有reducer是function类型的，才会进入最后的处理 if (typeof reducers[key] === 'function') { finalReducers[key] = reducers[key]; } } var finalReducerKeys = Object.keys(finalReducers); if (process.env.NODE_ENV !== 'production') { var unexpectedKeyCache = {}; } var sanityError; try { assertReducerSanity(finalReducers); } catch (e) { sanityError = e; } //这里是最终返回的函数，在createstore中的dispatch进行调用，传过来的是currentstate和action return function combination() { //取一个state为空对象或者是外面传进来的第一个 var state = arguments.length next => action => { if (typeof action === 'function') { return action(dispatch, getState); } return next(action); }; } 下面还是看applymiddleware： export default function applyMiddleware() { // 参数为所有的中间件，都在arguments里面，感觉应该整到一个对象里面~~ for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) { middlewares[_key] = arguments[_key]; } //循环完成后，所有的中间件都在middlewares里面 //最后返回出去的函数，参数是createstore；要能够拿到store，所以接收它的创建函数 return function (createStore) { // 在createstore中分开将createstore函数本身和它所需要的参数都传过来 return function (reducer, preloadedState, enhancer) { var store = createStore(reducer, preloadedState, enhancer); var _dispatch = store.dispatch; var chain = []; var middlewareAPI = { getState: store.getState, dispatch: function dispatch(action) { return _dispatch(action); } }; // 生成的chain最后的格式，一般是[next=>action=>{...next(action)},next=>action=>{...next(action)}...] chain = middlewares.map(function (middleware) { return middleware(middlewareAPI); }); // 生成一个加强的dispatch，这里就是比较吊的地方了，全是参数是函数，返回也是函数，这要看compose的代码了 _dispatch = compose.apply(undefined, chain)(store.dispatch); //增强后的dispatch兼容了中间件存在或不存在两种情况。然后对原始的store中的dispatch进行覆盖返回。 return _extends({}, store, { dispatch: _dispatch }); }; }; } compose.js //这个方法代码很少，但是理解起来很抽象。。 export default function compose(...funcs) { if (funcs.length === 0) { return arg => arg } if (funcs.length === 1) { return funcs[0] } //上面几行进行funcs的处理，没有或为1时的返回函数 为0时 返回的函数是 arg=>arg，接收最后的store.dispatch，返回的还是它，再赋给_dispatch，没变； 为1时 返回函数是funcs[0]，由上面的格式，next=>action=>{...next(action)}，传进来一个store.dispatch，再来一个action，最后的_dispatch就是function(action){//code... dispatch(action)}，记住，这里是函数！所以在外面还是可以这样传action来进行调用； //数组最后一个元素 const last = funcs[funcs.length - 1] //除最后一个元素之外的其他元素 const rest = funcs.slice(0, -1) //返回的是个函数，接收到的store.dispatch来做最后一个元素的参数，假设每个中间件只是console.log的话，last(...args)调用之后的结果就是(action)=>{console.log(1);dispatch(action)}，然后这个函数作为初值进行reduceRight，将这个函数传到rest数组的最后一个元素， 可以写成这样： let lastF = (action) => {console.log(1);store.dispatch(action)}; 将lastF作为参数传到(next)=>(action)=>{console.log(2);next(action)}中，结果是 (action)=>{console.log(2);lastF(action)}; 这就是rest最后一个元素处理后的结果函数 ... 可以发现，只要按照redux约定的中间件格式，最后的结果函数就是 (action) => { // code here... dispatch(action);//这个dispatch是redux提供的原始的函数 } 结果函数和最初的dispatch函数只是函数内容进行了增强，而参数和最终的发起action并没有变化！这就是最终增强的dispatch。 return (...args) => rest.reduceRight((composed, f) => f(composed), last(...args)) } redux还提供了一个bindactioncreators方法来将所有的action和dispatch进行关联，从而减少我们写的代码，下面上它： //核心是这个，传creator和dispatch进来，返回组合后的 function bindActionCreator(actionCreator, dispatch) { return (...args) => dispatch(actionCreator(...args)) } /***/ export default function bindActionCreators(actionCreators, dispatch) { //传的是函数，那就是代表这个就是actioncreator if (typeof actionCreators === 'function') { return bindActionCreator(actionCreators, dispatch) } if (typeof actionCreators !== 'object' || actionCreators === null) { throw new Error( `bindActionCreators expected an object or a function, instead received ${actionCreators === null ? 'null' : typeof actionCreators}. ` + `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?` ) } var keys = Object.keys(actionCreators) var boundActionCreators = {} // 对所有actions进行处理，组合出来所有的actioncreator for (var i = 0; i < keys.length; i++) { var key = keys[i] var actionCreator = actionCreators[key] if (typeof actionCreator === 'function') { boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) } } return boundActionCreators }","tags":[{"name":"redux","slug":"redux","permalink":"http://nicewahson.github.io/tags/redux/"}]},{"title":"mongo","date":"2017-01-10T10:36:07.000Z","path":"2017/01/10/mongo/","text":"mongose","tags":[{"name":"mongo","slug":"mongo","permalink":"http://nicewahson.github.io/tags/mongo/"}]},{"title":"crypto","date":"2017-01-06T07:59:36.000Z","path":"2017/01/06/crypto/","text":"crypto.getCiphers(),查看nodejs中能用的所有加密算法crypto.getHashes(),查看nodejs中能用的所有散列算法 dns模块dns.resolve(domain,[rrtype],callback),用于将一个域名解析为一组dns记录,callback为域名解析操作完成时调用的回调函数,function(err,addresses){}dns.lookup(domain,[family],callback),function(err,address,family){},family参数为4或6,表示获取到的ip地址类型为ip4或ip6dns.reverse(ip,callback),function(err,domains){},将ip反向解析为与该ip绑定的域名readline模块逐行读取流数据readline.createInterface(options),options对象中可以使用的{input:…,output:…,completer:function,terminal:boolean},completer用于指定tab补全处理 util模块format方法格式化debug(),error(),puts(),print(),log(string),log方法用于将一个字符串作为标准输出流进行输出,会在string之前加上当前时间输出util.inspect(object,[options]),返回一个字符串，串中包含了一个对象的信息util.isArray(object);util.isRegExp(object)util.isDate(object)判断是否为日期类型util.isError(object)判断是否为错误对象util.inherits(constructor,superConstructor)用于将一个父类的方法继承给该父类的子类","tags":[{"name":"crypto","slug":"crypto","permalink":"http://nicewahson.github.io/tags/crypto/"}]},{"title":"domain","date":"2017-01-04T10:15:59.000Z","path":"2017/01/04/domain/","text":"domain模块进行错误处理可以使用process.on(‘uncaughtException’,function(err){…})来捕获异常,单粗鲁，可能会资源泄漏，内存泄漏var domain = domain.create();返回一个domain对象，可以通过监听该对象的error事件并指定回调来实现当捕获到错误时的处理domain.on(‘error’,function(err){…}),使用domain的run方法指定domain对象监听的代码，这些代码要写在函数中，domain.run(fn)domain.add(emitter),可以对domain对象进行显示绑定domain.bind(callback),将一个回调函数与domain对象绑定，如果函数发生错误，交由domain对象domain.intercept(callback),和bind类似，区别是在bind的callback中要显示的throw error，而intercept不需要domain._stack查看domain堆栈中的内容domain.dispose(),销毁domain对象 assertassert.equal(actual,expected,[message]),参数：实际值，期望值，自定义异常信息,不相等会抛出assertionErrorassert.notEqual(…)…相等时会抛错assert.strictEqual(…)…,判断时连同类型一起判断,相当于===assert.ok(value,[message]),判断某个值是否为真assert.deepEqual(…)","tags":[{"name":"domain","slug":"domain","permalink":"http://nicewahson.github.io/tags/domain/"}]},{"title":"process","date":"2017-01-04T08:16:27.000Z","path":"2017/01/04/process/","text":"process.memoryUsage(),获取运行nodejs程序的进程的内存使用量。nextTick方法，用于将一个函数推迟到代码中所书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时调用,process.nextTick(callback)abort方法用于发出SIGABRT信号，使进程异常终止，同时产生一个核心文件chdir方法用于修改应用程序中使用的当前工作目录,process.chdir(directory),参数是一个字符串，相对或绝对路径cwd方法，返回当前目录exit方法用于退出nodejs应用程序进程,process,exit([code]),code指定为操作系统提供退出代码，为0时表示正常退出，默认为0getgid方法返回运行nodejs应用程序的进程组id，只在非windows系统有效setgid方法设置程序进程组id，只在非windows系统有效，process.setgid(id)getuid方法返回运行nodejs应用程序的进程的用户idsetuid。。。kill方法，向一个进程发送信号，process.kill(pid,[signal]),pid是进程号，signal可选，如SIGINT,SIGUSR1,默认为SIGTERM（表示中止该进程）uptime方法返回nodejs程序的当前运行时间，单位是秒。hrtime测试代码段的运行时间，返回一个数组，第一个参数是秒，第二个是毫秒child_process模块开启子进程child_process.spawn(command,[argv],[options])process.stdin.on(‘data’,function(data){}),process.stdout.write(data)开启子进程child_process.fork(modulePath,[args],[options])，使用此方法要显示关闭进程，process.exit(),发送消息可以使用process.send(m,[setHandle])当子进程收到消息时触发message事件，process.on(‘message’,function(m,[setHandle]){}),当发送时的setHandle为server或socket对象，那么收到时的也是。cluster.fork([env]),返回一个隐式创建的worker对象，表示使用fork方法开启的子进程中运行的nodejs应用程序实例对象，并且在该应用程序中运行一个模块文件，(默认是当前应用程序中使用的主模块文件)；cluster.on(‘fork’,function(worker){…});cluster.setupMaster([settings])修改子进程中运行的模块文件或修改子进程中运行的nodejs程序的其他默认行为","tags":[{"name":"process","slug":"process","permalink":"http://nicewahson.github.io/tags/process/"}]},{"title":"httpserver","date":"2016-12-24T02:59:16.000Z","path":"2016/12/24/httpserver/","text":"querystring.parse(str,[sep],[eq],[options]),str为转换的查询字符串,sep参数是该字符串中的分隔字符,默认为’&amp;’,eq是分配字符,默认为’=’,options是一个对象,可以在该对象中用一个整数类型的maxKeys属性指定转换后的属性个数,设置为0时等同于不使用maxKeysquerystring.stringify(obj,[sep],[eq]),作用和parse相反url.parse(urlStr,[parseQueryString]),将url字符串转换为一个对象,对象中有很多属性,比如query,为查询字符串,parseQueryString为布尔值,默认为false,为true时表示转换后的对象中的query字符串同时转换为对象url.format(urlobj),将url转换后的对象还原成字符串url.resolve(from,to),与path.resolve()方法类似response.writeHead(statusCode,[reasonPhrase],[headers]),第二个是状态码的描述信息,第三个是响应头response.write(chunk,[encoding]),encoding默认为utf8发送响应数据时，如果数据量过大或网络较慢，server会将数据缓存到内存中，然后在可以接收数据的时候将内存中的数据通过操作系统内核缓存区发送给对方write方法返回布尔值，为true时表示数据是直接发送到内核缓存区，为false表示先存到内存中。response.setTimeout(msecs,[callback]),设置响应超时时间，msecs是时间，callback是超时后的回调，如果不设置这个，或者不在timeout事件指定回调函数，那么当响应超时时会自动关闭与客户端连接的端口。var request = http.request(options,callback),options可以是字符串,如果是字符串,将自动使用url模块中的parse方法转换为一个对象。callback为function(response){}，表示获取到返回的响应流时调用的回调函数。每次调用request方法后，必须要加一个req.end()方法来结束本次请求。也可以直接使用http.get(options,callback),仅限于get方法，而且在结束请求时不需要手动调用end()","tags":[{"name":"http server","slug":"http-server","permalink":"http://nicewahson.github.io/tags/http-server/"}]},{"title":"net模块udpserver","date":"2016-12-21T10:00:23.000Z","path":"2016/12/21/net模块udpserver/","text":"net模块创建udp服务器udp协议是面向非连接的协议，不要求先建立连接，不安全但是速度快，更实时var dgram = require(‘dgram’);var net = dgram.createSocket(type,[callback]),type指定进行udp通信的协议类型，可为’udp4’或’udp6’,callback用于指定当从该端口接收到数据时调用的回调，function(msg,rinfo){…},msg是一个buffer对象，其中存放接收到的数据，rinfo参数是一个对象，所具有的属性 address:发送者的ip，family:标识发送者的ip是ipv4还是ipv6，port为发送者的socket端口号，size为发送者所发送的数据字节数，在从该socket端口中接收到数据时，触发message事件,所以也可以使用socket.on(‘message’,function(msg,ringo){})创建socket对象后，必须使用socket.bind(prot,[address],[callback],这样udp客户端才知道往哪个地址发数据，也可以不使用bind方法中的callback方法，绑定完后开始监听时触发socket.on(‘listening’,callback),指定当socket端口对象开始监听来自于指定地址和端口号的数据时所要执行的处理socket.send(buf,offset.length,port,address,[callback]),缓冲区，开始时的位置，发送的字节数，接受数据的socket端口对象所使用的端口号，地址，发送完毕的回调，function(err,bytes){…}socket.close()方法关闭该socket端口对象，停止从该端口上监听数据，如果此时应用程序不再执行其他代码，整个应用会正常关闭。当关闭时触发close事件.socket.setTTL(input),input为0-255的数字，设置数据包的生存时间。socket.setBroadcast(flag),布尔类型参数，为true时表示服务器或客户端可以利用socket对象的send方法进行广播","tags":[{"name":"tcp和udp通信","slug":"tcp和udp通信","permalink":"http://nicewahson.github.io/tags/tcp和udp通信/"}]},{"title":"tcp和udp通信","date":"2016-12-10T07:14:52.000Z","path":"2016/12/10/tcp和udp通信/","text":"net模块创建tcp服务器var net=require(‘net’),var server=net.createServer([options],[connectionListener]),connectionListener为function(socket){}是建立连接时的回调函数,socket是tcp服务器监听的socket端口对象server.listen(port,[host],[backlog],[callback]),port是端口号，为0时分配随机端口，tcp服务器会监听来自这个端口的连接，host是主机，忽略的话则监听任意ipv4的客户端连接，backlog指定位于等待队列中的客户端连接的最大数量，超过后tcp服务器将拒绝来自新的客户端请求，默认为511，服务器开始监听时触发listening事件，触发callback方法。server.address()查看服务器所监听的地址信息.server.getConnections(function(err,count){});方法获取当前连接数，可以设置服务器的最大连接数server.maxConnectionsserver.close([callback]),指定服务器拒绝所有新的客户端连接,当现有连接全部关闭时触发close事件，调用close方法server.on(‘close’,function(){…});socket.on(‘data’,function(data){…}),socket对象可以被用来读取客户端发送的流数据，每次接收到客户端发送的流数据时触发data事件，当收到另一侧传来的数据时触发socket.pipe(destination,[options]),destination为一个可用于写入流数据的对象,options是一个对象，可以在对象中使用一个布尔类型的end属性，如果属性为true，当数据读完时立即结束写操作，为false，为true时不结束，可以被继续写入新数据，默认为truesocket.setEncoding(‘utf8’),设置读取到的数据的编码格式socket.on(‘error’,function(err){err.code…}),发生错误时触发此函数,同时,错误时应该调用socket.destroy()方法销毁该socket端口对象socket.end([data],[encoding]),服务端使用end关闭该客户端连接，客户端使用end关闭该服务端连接,data表示在关闭前向另一端追加发送的数据,可以是buffer，也可以是字符串创建tcp客户端var client = new net.Socket([options]),client.setEncoding(‘utf8’),client是一个socket对象,在需要往客户端或服务器传数据时，可以使用socket.write(data,[encoding],[callback]),callback是数据写入完毕时的回调，没有参数。client.end(‘end’),表示关闭连接时追加数据。socket.on(‘end’,function(){ server.unref(‘客户端连接关闭时关闭服务器’);})socket.on(‘close’,function(has_error){ if(has_error) server.unref(‘客户端连接关闭时关闭服务器’);});监听close事件，与server.close()方法不同。socket.setKeepAlive([enable],[initialDelay]),第一个参数表示是否启用探测机制，默认为false，第二个参数是探测间隔时间，隔多久探测一次对方机器，默认为0net.isIP(input),用于判断一个字符串是否是一个ip地址，不是ip的话返回0，是ipv4的话返回4，ipv6的话返回6net.isIPv4(input),判断字符串是否是一个ipv4地址net.isIPv6(input),判断是否是ipv6地址","tags":[{"name":"tcp和udp通信","slug":"tcp和udp通信","permalink":"http://nicewahson.github.io/tags/tcp和udp通信/"}]},{"title":"读写文件2","date":"2016-12-06T03:20:45.000Z","path":"2016/12/06/读写文件2/","text":"var fs=require(‘fs’); //同步读取，读取配置文件时可以使用fs.readFileSync(‘./index.html’,’utf-8’);fs.readFile(‘./index.html’,’utf-8’,function(err,data){ console.log(data);//操作完毕后打印结果 }) //异步读取fs.readFile(filename,[options],callback);如果不在options参数中指定encoding参数，那么读取的结果得到的是一个二进制buffer对象。options中可以用的属性,flag(以何种方式读或是写),encodingfs.writeFile(filename,data,[options],callback);options中可以用的属性，flag,mode(读写权限),encoding(可指定属性值为’utf-8’,’ascii’,’base64’,当data为buffer对象时该属性自动忽略)fs.appendFile(…),参数同上，在文件底部追加数据，和上面不同的是，options中的flag属性默认值为’a’,表示向文件底部追加，如果文件不存在，创建文件从指定位置读写文件开始读写之前,先fs.open(filename,flags,[mode],function(err,fd){…}),fd是文件描述符然后fs.read(fd,buffer,offset,length,position,callback),参数： fd:open方法返回的文件描述符，buffer是一个Buffer对象，表示将文件数据读取到哪个缓冲区，offset指定向缓冲区写入数据时的开始写入位置，length参数用于指定从文件中读取的字节数，position用于指定读取文件时的开始位置(以字节为单位),callback指定,function(err,bytesRead,buffer){//bytesRead参数值代表实际读取的字节数，buffer为被读取的缓存区对象} 如果position为null,表示从当前位置开始继续读取(前一次读取的开始位置+字节数)，应该写在上一次read方法的回调里 write方法：fs.write(fd,buffer,offset,length,position,callback)buffer为被写入的缓冲区，offset为指定从缓冲区中读取数据时的开始位置，length为写入的字节数，position为写入文件时的开始位置，callback:function(err,written,buffer),written代表实际写入字节数position为null时，表示从当前位置开始继续写入。当想要向文件中追加数据时，需要在open方法中设置flag为’a’,只是一次的写入可以是’w’ 在写完之后，可以调用close方法，fs.close(fd,[callback]),callback中参数为err write方法是将数据写入到内存，再将内存中数据写入到文件，因此当写了一些数据，并不代表内存缓冲区中已经空了，可能还有数据，这时候调用close方法会有数据丢失的问题，这时候需要一个方法fs.fsync(fd,[callback])，文件同步操作,调用close方法后再进行调用将内存缓冲区的数据全部写到文件中 fs.mkdir(path,[mode],callback),path是被创建的目录的完整路径及目录名,callback是创建完成时的回调fs.readdir(path,callback),callback格式function(err,files){}fs.stat(path,callback),fs.lstat(path,callback),查看文件或目录信息,callback为function(err,stats),stats是一个fs.Stats对象检查文件或目录是否存在，fs.exists(path,callback),path是全路径,callback为function(exists){},exists是true或false获取文件或目录绝对路径，fs.realpath(path,[cache],callback),cache是一个对象，存放一些预先指定的路径,function(err,resolvedPath){},后一个参数是全路径var cache = {‘/etc’:’/private/etc’};fs.realpath(‘/etc/passwd’,cache,function(err,resolvedPath){}) 修改文件访问时间和修改时间fs.utimes(path,atime,mtime,callback),atime是指定修改后的访问时间,mtime是修改后的修改时间修改文件或目录的读写权限fs.chmod(path,mode,callback),chmod: user group other,read-write-excute移动文件或目录fs.rename(oldpath,newpath,callback),oldpath是被移动文件或目录的完整路径及文件或目录名，newpath是移动后的完整路径及文件或目录名截断文件fs.truncate(path,len,callback),len是截断后的文件大小(单位是字节数)删除空目录fs.rmdir(path,callback)监视文件或目录fs.watchFile(filename,[options],listener),文件名filename，options是一个对象，可以用一个persistent:true(false)表示指定当指定了被监视的文件后是否停止当前正在运行的程序，也可以是interval:xxx，整数，表示多少时间监视一次,callback为function(curr,prev){}fs.unwatch(filename,[listener]),取消监视ReadStream读取文件fs.createReadStream(path,[options]),返回一个file文件输入流,在这里对其添加事件回调var file = fs.createReadStream(‘./a.txt’,{start:3,end:12});file.on(‘open’,function(fd){console.log(‘文件打开’)});file.on(‘data’,function(data){console.log(‘文件读到数据’)});WriteStream写入文件var out = fs.createWriteStream(path,[options])，返回一个输出流，out.write(data,[encoding],[callback]),该方法返回一个bool值，表示缓存区中是否已经满，满了为false复制文件方法pipe(destination,[options]),destination是写入流数据的对象，options对象中可以使用一个end属性，为true的话表示读完数据后关闭文件，false的话则不关闭，还可以继续写入，默认为true path模块normalize(path)将非标准路径字符串转换为标准字符串join([path1],[path2]…),将多个参数值字符串结合为一个路径字符串resolve解析路径relative(from,to)获取两个相对路径之间的关系dirname(path),获取路径中的目录名basename(path,[ext]),获取路径中的文件名，path为完整路径，ext为可选参数，用于在方法返回的文件名中去除该文件的扩展名extname(path),获取文件扩展名","tags":[{"name":"文件操作","slug":"文件操作","permalink":"http://nicewahson.github.io/tags/文件操作/"}]},{"title":"读写文件1","date":"2016-11-21T10:33:07.000Z","path":"2016/11/21/读写文件1/","text":"var fs=require(‘fs’); //同步读取，读取配置文件时可以使用fs.readFileSync(‘./index.html’,’utf-8’);fs.readFile(‘./index.html’,’utf-8’,function(err,data){ console.log(data);//操作完毕后打印结果 }) //异步读取fs.readFile(filename,[options],callback);如果不在options参数中指定encoding参数，那么读取的结果得到的是一个二进制buffer对象。options中可以用的属性,flag(以何种方式读或是写),encodingfs.writeFile(filename,data,[options],callback);options中可以用的属性，flag,mode(读写权限),encoding(可指定属性值为’utf-8’,’ascii’,’base64’,当data为buffer对象时该属性自动忽略)fs.appendFile(…),参数同上，在文件底部追加数据，和上面不同的是，options中的flag属性默认值为’a’,表示向文件底部追加，如果文件不存在，创建文件从指定位置读写文件开始读写之前,先fs.open(filename,flags,[mode],function(err,fd){…}),fd是文件描述符然后fs.read(fd,buffer,offset,length,position,callback),参数： fd:open方法返回的文件描述符，buffer是一个Buffer对象，表示将文件数据读取到哪个缓冲区，offset指定向缓冲区写入数据时的开始写入位置，length参数用于指定从文件中读取的字节数，position用于指定读取文件时的开始位置(以字节为单位),callback指定,function(err,bytesRead,buffer){//bytesRead参数值代表实际读取的字节数，buffer为被读取的缓存区对象}","tags":[{"name":"文件操作","slug":"文件操作","permalink":"http://nicewahson.github.io/tags/文件操作/"}]},{"title":"nodejs_buff","date":"2016-11-21T09:46:22.000Z","path":"2016/11/21/node_buffer/","text":"构造buffernew Buffer(size),size为缓存区大小buf.fill(value,[offset],[end]),此方法对buffer进行初始化,value必填，表示需要被写入的数值，第二个参数表示从第几个参数写入，默认为0，第三个参数表示写入到第几个字节处，默认为buffer对象大小，即书写到缓存区底部new Buffer(array),array是指定数值数组 eg: newBuff([1,2,3])//(Buffer 00 01 02)new Buffer(str,[encoding]),缓冲区中存放的是原字符串的十六进制表现形式，使用字符串初始化缓冲区，第二个参数为指定文字进行编码，不同编码字符串生成缓冲区对象，ascii编码和u8编码生成的是相同的，其他的是不同的，也就会把不同的数据放在缓冲区。缓冲区对象存在length属性，可以获取长度，也可以使用下标形式获取制定位置的值。 Buffer对象与字符串对象相互转换toString方法，buf.toString([encoding],[start],[end]),第一个参数默认u8，二三表示转换的起始终止位置write方法向已创建buffer对象写入字符串，buf.write(string,[offset],[length],[encoding]),第一个参数指定写入内容，offset和length参数指定字符串转为字节数据后的写入位置，offset是下标。书写位置从第1+offset个字节开始到offset+length个字节为止。第四个参数编码默认u8。StringDecoder对象var StringDecoder=require(‘string_decoder’).StringDecoder;decoder=new StringDecoder([encoding]);encoding默认u8decoder.write(buffer);将buffer对象中的数据转为字符串Buffer对象和JSON对象转换JSON.stringify方法将buffer对象中保存的数据转换为一个字符串，再用JSON.parse方法将转换后的字符串还原为一个数组，这个数组可以用来构造Buffer对象 复制缓存数据，将一个buffer对象中以保存的二进制数据复制到另一个buffer对象中。buf.copy(targetBuffer,[targetStart],[sourceStart],[sourceEnd]),a.copy(b,10),一直复制到b的末尾，不会再继续复制。 Buffer的类方法isBuffer方法判断一个对象是否是一个Buffer对象，Buffer.isBuffer(obj)byteLength用于计算指定字符串的字节数，Buffer.byteLength(string,[encoding])concat方法将多个buffer对象连接起来，Buffer.concat(list,[totalLength]),list代表多个buffer对象形成的数组，第二个参数用于指定拼接后生成的buffer对象的长度isEncoding方法用于检测一个字符串是否是一个有效的编码格式字符串，Buffer.isEncoding(encoding);","tags":[{"name":"nodejs buffer","slug":"nodejs-buffer","permalink":"http://nicewahson.github.io/tags/nodejs-buffer/"}]}]